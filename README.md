# Juegos-de-los-Pancakes-aplicando-IDA
Juego de los pancakes (pancake sorting) aplicando IDA

Hecho por Marcos Zacarias, ITC-TM, Universidad Autonoma de Baja California Sur

Pequeña explicacion de las funciones:

--"void voltear(string& pancakes, int k)" Esta función recibe una cadena de caracteres, en este caso, los pancakes, y un entero k, y voltea los primeros k caracteres de la cadena. Se utiliza para simular la acción de voltear un número determinado de pancakes en una pila.

--"bool esta_ordenada(string pancakes)" Esta función recibe una cadena de caracteres pancakes y devuelve true si la cadena está ordenada de forma ascendente, es decir, si cada caracter es mayor o igual al caracter que le precede en la cadena. Se llama para verificar si el parametro que recibe esta ordenado.

--"vector generar_sucesores(string pancakes)" Esta función recibe una cadena de caracteres pancakes y devuelve un vector de cadenas de caracteres, son las posibles opciones de voltear distintos numeros de pancakes del arreglo. Se usa para generas sucesores de la cadena actual que recibe y los agrega a la cola de busqueda.

--"string generar_caracteres_aleatorios(int n)" Esta función recibe un entero n y devuelve una cadena de caracteres de longitud n, se usa para generar caracteres aleatorios, asi ahorrando estar pidiendo al usuario que se ingrese caracter por caracter.

--"float h4(const string& pancakes, const string& target)" Esta función es la heurística utilizada por el algoritmo de búsqueda A*. Recibe dos cadenas de caracteres, pancakes y target, y devuelve un entero que representa el costo estimado desde pancakes hasta target. La heurística utilizada es la siguiente: para cada posición de pancakes, si el caracter en esa posición es diferente al caracter correspondiente en target, se suma 1 al costo. Además, si hay dos caracteres consecutivos en pancakes que están separados por más de una posición en target, se suma 1 al costo. Por ejemplo, si pancakes es "adcbe" y target es "abcde", el costo estimado será 2, ya que hay dos caracteres diferentes ("d" y "b") y un par de caracteres consecutivos separados por más de una posición ("c" y "e"). Se cambio a tipo float para devolver una estimacion un poco mas precisa.

--"String ida_estrella"
Recibe como parámetros la pila de pancakes actual, la cadena objetivo, el costo actual, el umbral actual, el camino actual y una referencia al número de nodos visitados. La función primero calcula el valor de f como la suma del costo actual y la heurística h4 aplicada a la pila de pancakes actual y la cadena objetivo. Si f es mayor que el umbral actual, la función devuelve "inf". Si la pila de pancakes actual ya está ordenada, la función devuelve el camino actual. De lo contrario, se generan los sucesores de la pila de pancakes actual mediante la función generar_sucesores. Para cada sucesor, se verifica si ya está en el camino actual o si su costo más la heurística h4 es mayor que el umbral actual. En ambos casos, se incrementa el contador de nodos visitados y se continua con el siguiente sucesor. Para los sucesores restantes, se incrementa el costo actual en uno, se llama recursivamente a la función ida_estrella con el sucesor como pila de pancakes actual, el nuevo costo actual, el umbral actual, el camino actual actualizado y la referencia al contador de nodos visitados. 

--"int main()" a función main comienza pidiendo al usuario que ingrese un entero n que determinará el tamaño de la cadena de caracteres aleatorios que se utilizarán para representar la pila de pancakes original. Luego se genera la cadena aleatoria mediante la función generar_caracteres_aleatorios y se la muestra en pantalla. A continuación se ordena la cadena objetivo y se inicializa el umbral threshold con el resultado de aplicar la heurística h4 a la cadena original y la cadena objetivo. Luego se inicia un bucle que llamará a la función ida_estrella con diferentes umbrales hasta que encuentre una solución. En cada iteración del bucle, si la función ida_estrella devuelve "inf", aumenta el umbral y vuelve a llamar a la función. Si se encuentra una solución, se muestra en pantalla y se termina el bucle. Por último, se muestra el número de nodos visitados durante todo el proceso.
